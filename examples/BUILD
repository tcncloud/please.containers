subinclude('//:containers')

container_toolchain(name = 'toolchain', use_internal=True)

filegroup(
    name = 'inject',
    srcs = [
        "testfile1",
        "testfile2",
    ]
)

filegroup(
    name = 'inject_two',
    srcs = [
        "testfile3",
    ]
)

# DESCRIPTION:
# * name            Mandatory - name of the rule
# * image           Mandatory - which image to pull
# * tag             Mandatory - which image version to pull
# * repository      Optional (default = "index.docker.io")
# Pull an image from the registry and save it for future use; 

container_pull(
    name = 'ubuntu',
    image = 'ubuntu',
    tag = '20.04',
)

# DESCRIPTION: 
# This rule's srcs MUST be a multi-layer container_pull rule; it creates a container one with a single merged layer

container_flattener(
    name = 'ubuntu_flat',
    srcs = [ ":ubuntu" ],
)

# DESCRIPTION:
# * name             Mandatory. The name of the rule
# * srcs             Mandatory. The list of targets that generate the file or files to be included. 
# * destination      Mandatory. The destination directory. 
# All files inserted into the layer will be 
# * owned by nobody:nogroup
# * mode 644 if they come from a normal please rule
# * mode 755 if they come from a rule marked as "binary"
# * placed in the same directory; if different destinations are required, one must define multiple rules

container_layer(
    name = 'mylayer',
    srcs = [ ":inject" ],
    destination = "/opt/foo",
)

container_layer(
    name = 'myotherlayer',
    srcs = [ ":inject_two" ],
    destination = "/opt/bar",
)

# DESCRIPTION:
# * name             Mandatory. The name of the rule
# * srcs             Mandatory. The list of layers that compose the image
# * description      Optional. The container description as it would be generated by docker
# * image_labels     Optional. Embedded image labels
# * environment      Optional. Same as doing ENV in a Dockerfile
# * entrypoint       Optional. Same as ENTRYPOINT in a Dockerfile
# * command          Optional. Same as CMD in a Dockerfile
# * ports            Optional. Same as EXPOSE in a Dockerfile
# * osversion        Optional (default = linux). 
# * architecture     Optional (default = amd64).

container_config(
    name = 'myimage_config',
    srcs = [
        ":ubuntu_flat",
        ":mylayer",
        ":myotherlayer",
    ],
    description = "Foobar image",
    image_labels = {
        "version": "v1.2.3",
        "foo": "bar",
        "baz": "bla",
    },
    environment = {
        "FOO": "BAR",
    },
    entrypoint = ["/bin/bash"],
    command = [ 
        "-c",
        "foo",
    ],
    ports = [
        "80",
        "443",
    ],
)

container_config(
    name = 'myotherimage_config',
    srcs = [
        ":ubuntu_flat",
        ":myotherlayer",
    ],
    description = "Foobaz image",
    image_labels = {
        "version": "v3.2.1",
    },
    entrypoint = ["/bin/bash"],
)

# DESCRIPTION:
# * name           Mandatory. The name of the rule; note that the rule will generate 2 separate rules, the one that does the push is called '${name}_push'; invoking just the name won't work
# * srcs           Mandatory. The ORDERED list of layers that compose the image. Always start with the baseimage (if any), followed by smaller layers; the LAST one MUST be a previously defined "container_config" target.
# * image_name     Optional. The name of the generated image; if absent, will use the ${name} field
# * tag            Optional. Extra tag for the image. The rule uses by default 12 chars from the digest of the image and the $CI_COMMIT_TAG variable (if defined);
# REQUIREMENTS:
# * CLOUDSDK_CONFIG has to point to the real $HOME/.config/gcloud directory (by default), otherwise push will fail, since please sets $HOME to the current build dir
# * DOCKER_CONFIG has to point to a $HOME/.docker with configured docker credentials/helpers for private repos use-case;
# * any credential helper for docker has to be linked into /usr/local/bin or /usr/bin (e.g. docker-credential-gcloud)
container_push(
    name = 'myimage',
    srcs = [
        ":ubuntu_flat",
        ":mylayer",
        ":myotherlayer",
        ":myimage_config",
    ],
    image_name = "foo",
    tag = "foobarv2",
)

container_push(
    name = 'myotherimage',
    srcs = [
        ":ubuntu_flat",
        ":myotherlayer",
        ":myotherimage_config",
    ],
    image_name = "bar",
    tag = "foobazv2",
)


container_make(
    name = 'myimage_fu',
    srcs = [
        ":ubuntu_flat",
        ":mylayer",
        ":myotherlayer",
    ],
    description = "Foobar image",
    image_labels = {
        "version": "v1.2.3",
        "foo": "bar",
        "baz": "bla",
    },
    environment = {
        "FOO": "BAR",
    },
    entrypoint = ["/bin/bash"],
    command = [ 
        "-c",
        "foo",
    ],
    ports = [
        "80",
        "443",
    ],
    image_name = 'myimage',
    tag = 'v1.2.3',
)

container_make(
    name = 'myotherimage_fu',
    srcs = [
        ":ubuntu_flat",
        ":myotherlayer",
    ],
    description = "Foobaz image",
    image_labels = {
        "version": "v3.2.1",
    },
    entrypoint = ["/bin/bash"],
    image_name = 'myotherimage',
    tag = 'v3.2.1',
)