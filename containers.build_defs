


def container_toolchain(name:str, url:str = None, version:str = "v0.0.1", hashes:list = [], visibility:list = ['PUBLIC']):
    return build_rule(
        name = name, 
        srcs = [
            remote_file(
                name = name, 
                _tag = "download",
                url = f"https://github.com/tcncloud/please.containers/releases/download/{version}/rules_docker_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}.tar.gz" if not url else url,
                hashes = hashes,
            )
        ],
        visibility = visibility,
        cmd = ' && '.join([
            f'mkdir {name}',
            f'tar xf $SRCS -C {name}',
        ]),
        outs = [name],
        entry_points = {
            'create_image_config': f"{name}/create_image_config/create_image_config_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}",
            'digester': f'{name}/digester/digester_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}',
            'extract_config': f'{name}/extract_config/extract_config_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}',
            'flattener': f'{name}/flattener/flattener_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}',
            'join_layers': f'{name}/join_layers/join_layers_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}',
            'loader': f'{name}/loader/loader_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}',
            'puller': f'{name}/puller/puller_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}',
            'pusher': f'{name}/pusher/pusher_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}',
            'update_deps': f'{name}/update_deps/update_deps_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}',
            'zipper': f'{name}/zipper/zipper_{CONFIG.HOSTOS}_{CONFIG.HOSTARCH}',
        },
        binary = True,
    )

def container_pull(name: str, image: str, tag:str='latest', registry:str='index.docker.io', toolchain:str = ":toolchain", visibility:list=[]): 
    return build_rule(
        name = name, 
        visibility = visibility,
        cmd = " && ".join([
            f"if [[ {registry} =~ gcr\.io && ! -e /usr/local/bin/docker-credential-gcloud ]]; then echo This target requires /usr/local/bin/docker-credential-gcloud; exit 1; fi",
            f"if [[ {registry} =~ gcr\.io && -z $CLOUDSDK_CONFIG ]]; then echo This target requires CLOUDSDK_CONFIG to point to where gcloud keeps its configuration; exit 1; fi",
            f"if [[ {registry} =~ gcr\.io && -z $DOCKER_CONFIG ]]; then echo This target requires DOCKER_CONFIG to point to where docker keeps its configuration; exit 1; fi",
            f"mkdir -p {name}",
            f"$TOOLS_PULLER -name {registry}/{image}:{tag} -directory {name} -os linux -architecture amd64",
            f"cd {name}",
            "for i in *.sha256; do mv $i ${i%.*}.tar.gz.sha256; done",
            "for i in *.tar.gz; do gzip -dk $i; echo -n $($TOOL_SHA256 ${i%.*} | cut -f1 -d' ') > ${i%.*}.sha256; done",
        ]),
        outs = [ name ],
        building_description = "Pulling image ...",
        pass_env = [
            "CLOUDSDK_CONFIG",
            "DOCKER_CONFIG",
            "CLOUDSDK_ACTIVE_CONFIG_NAME",
        ],
        tools = {
            'puller': [toolchain+"|puller"],
            'join_layers' : [toolchain + "|join_layers"],
        },
    )

def container_flattener(name:str, baseimage:str, toolchain:str = ':toolchain', visibility:list=[]):
    return build_rule(
        name = name,
        visibility = visibility,
        outs = [ name ],
        cmd = " && ".join([
            f"mkdir -p {name}",
            "flatten_layers=\"\"",
            f"workdir=$(location {baseimage})",
            "for t in $(ls -1 $workdir/*.tar); do flatten_layers=\"${flatten_layers} -layer ${t}.gz,${t},${t}.gz.sha256,${t}.sha256\"; done",
            f"$TOOLS_FLATTENER -config $workdir/config.json -manifest $workdir/manifest.json -filesystem {name}/000.tar -metadata {name}/.combined.json ${flatten_layers}",
            f"$TOOLS_ZIPPER -dst {name}/000.tar.gz -src {name}/000.tar",
            f"echo -n $($TOOL_SHA256 {name}/000.tar | cut -f1 -d' ') > {name}/000.tar.sha256",
            f"echo -n $($TOOL_SHA256 {name}/000.tar.gz | cut -f1 -d' ') > {name}/000.tar.gz.sha256",
            f"rm -f {name}/.combined.json",
        ]),
        tools = {
            'flattener': [toolchain+"|flattener"],
            'zipper': [toolchain+"|zipper"],
        },
        deps = [
            baseimage,
        ],
    )

def container_inject(name:str, baseimage:str, srcs:list, destination:str, timestamp:str='0', toolchain:str = ':toolchain', owner:str = '0', group:str = '0', perms:str = '0755', visibility:list=[]):
    dst = destination.lstrip('/')
    datefmt = '+%Y-%m-%dT%H:%M:%S%z'
    
    if CONFIG.HOSTOS == 'darwin':
        datecmd = 'date -j -f "%s" '
    else:
        datecmd = 'date -d @'

    return build_rule(
        name = name,
        visibility = visibility,
        outs = [ name ],
        srcs = srcs,
        cmd = " && ".join([
            f"which $TOOL_TAR || (echo This tool requires $TOOL_TAR - please install it via brew; exit 1)",
            f"srcdir=$(location {baseimage})",
            f"workdir={name}",
            f"mkdir -p $workdir/.layer/{dst}",
            f"cp $srcdir/* {name}",            
            f"cp -v $SRCS $workdir/.layer/{dst}",
            f"for f in $SRCS; do chmod {perms} $workdir/.layer/{dst}/$(basename $f); done",
            f"next_file=$(ls -1 $workdir/*.tar | wc -l | tr -d ' ')",
            f"pad=000",
            "layer_name=${pad:0:-${#next_file}}${next_file}",
            "cwd=$(pwd)",
            f"cd $workdir/.layer",
            f"create_time=$({datecmd}{timestamp} {datefmt})",
            f"$TOOL_TAR cf ../$layer_name.tar --owner {owner} --group {group} --mtime=${create_time} *",
            "cd $cwd",
            "$TOOLS_ZIPPER -src $workdir/$layer_name.tar -dst $workdir/$layer_name.tar.gz",
            "echo -n $($TOOL_SHA256 $workdir/$layer_name.tar | cut -f1 -d' ') > $workdir/$layer_name.tar.sha256",
            "echo -n $($TOOL_SHA256 $workdir/$layer_name.tar.gz | cut -f1 -d' ') > $workdir/$layer_name.tar.gz.sha256",
            f"rm -rf $workdir/.layer",
        ]),
        tools = {
            'zipper': [ toolchain+"|zipper" ],
        },
        deps = [
            baseimage,
        ]
    )

def container_config(name:str, baseimage:str, timestamp:str='0', toolchain:str = ':toolchain', description:str = '', labels:dict = {}, entrypoint:list = [], command:list = [], environment:dict = {}, ports:list = [], osversion:str = 'linux', architecture:str = 'amd64', visibility:list = ['PUBLIC']):
    my_labels = ''
    for l in labels.keys():
        v = labels[l]
        my_labels = f"{my_labels} -labels {l}={v}"
    
    my_environment = ''
    for e in environment.keys():
        v = environment[e]
        my_environment = f"{my_environment} -env {e}={v}"

    my_ports = ''
    if len(ports) > 0:
        for p in ports:
            my_ports = f"{my_ports} -ports {p}"
    
    my_entrypoint = ''
    if len(entrypoint) > 0:
        for e in entrypoint:
            my_entrypoint = f"{my_entrypoint} -entrypoint {e}"
    else:
        my_entrypoint = "-nullEntryPoint"
    
    my_command = ''
    if len(command) > 0:
        for c in command:
            my_command = f"{my_command} -command {c}"
    else:
        my_command = "-nullCmd"
    
    return build_rule(
        name = name,
        visibility = visibility,
        output_dirs = [
            name
        ],
        cmd = " && ".join([
            f"workdir={name}",
            f"srcdir=$(location {baseimage})",
            f"mkdir -p $workdir && cp $srcdir/* $workdir",
            "layers=()",
            "layer_digests=()",
            "for f in $(ls -1 $workdir/*.tar); do layers=( ${layers[@]} -layer $f.gz,$f,$f.gz.sha256,$f.sha256 ); layer_digests=( ${layer_digests[@]} -layerDigestFile @${f}.sha256 ); done",
            f"$TOOLS_CREATE_IMAGE_CONFIG -outputConfig $workdir/flat.config.json -outputManifest $workdir/flat.manifest.json {my_labels} {my_environment} {my_ports} {my_entrypoint} {my_command} -creationTime {timestamp} ${layer_digests[@]}",
            "$TOOLS_DIGESTER -config $workdir/flat.config.json ${layers[@]} -manifest $workdir/flat.manifest.json -format Docker -dst $workdir/flat.digest",
        ]),
        tools = {
            'create_image_config': [toolchain+"|create_image_config"],
            'digester': [toolchain+"|digester"],
        },
        deps = [
            baseimage,
        ]
    )

# CAVATS:
# CLOUDSDK_CONFIG has to point to the $HOME/.config/gcloud directory, otherwise push will fail;
# DOCKER_CONFIG has to point to a $HOME/.docker with configured docker credential/helper for gcr.io cases or some other auth completed already for private repos;
# if the docker-credential-gcloud is being used, it has to be symlinked into the limited PATH used by please - either /usr/local/bin or /usr/bin
# TODO: find a way to remote the unnecessary output
def container_push(name:str, baseimage:str, repository:str, tag:str = '', image_name:str = '', toolchain:str = ':toolchain', visibility:list = ['PUBLIC']):
    outfile = f"{name}_run.sh"
    return build_rule(
        name = name,
        visibility = visibility,
        cmd = " && ".join([
            f"S=( $(out_locations {baseimage}) )",
            f"outfile={outfile}",
            "for file in ${S[@]}; do if [[ $file =~ \.tar$ ]] ; then tarfiles=( ${tarfiles[@]} $file); elif [[ $file =~ flat\.config\.json$ ]]; then config_json=$file; elif [[ $file =~ flat\.manifest\.json ]]; then manifest_json=$file; elif [[ $file =~ flat\.digest$ ]]; then digest_file=$file; fi; done",
            f"if [[ -z \"{image_name}\" ]]; then image_name={name}; else image_name={image_name}; fi",            
            "printf '#!/usr/bin/env bash\n' > $outfile",
            f"printf 'tarfiles=( %s )\n' \"$( echo ${tarfiles[@]} )\" >> $outfile",
            "printf 'layers=()\n' >> $outfile",
            f"printf 'if [[ -z \"{tag}\" ]]; then tag=$(cat %s | cut -f2 -d: | fold -w 12 | head -n1); else tag=\"{tag}\"; fi\n' $digest_file >> $outfile",
            "printf 'for f in ${tarfiles[@]}; do layers=( ${layers[@]} -layer $f.gz,$f,$f.gz.sha256,$f.sha256 ); done\n' >> $outfile",
            f"printf '%s -config %s -manifest %s ${layers[@]} -format Docker -dst {repository}/%s:$tag\n' $TOOLS_PUSHER $config_json $manifest_json $image_name >> $outfile",
            f"printf 'if [[ -n \"$CI_COMMIT_TAG\" ]]; then %s -config %s -manifest %s ${layers[@]} -format Docker -dst {repository}/%s:$CI_COMMIT_TAG; fi\n' $TOOLS_PUSHER $config_json $manifest_json $image_name >> $outfile",
        ]),
        outs = [
            outfile,
        ],
        binary = True,
        tools = {
            'pusher': [ toolchain+"|pusher" ],
        },
        deps = [
            baseimage,
        ]
    )